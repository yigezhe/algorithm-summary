冒泡排序是一个相邻元素比较法，通过一个个相邻元素的比较最终找到当前最大值
冒泡排序可以保证相邻的相同元素的相对位置不会变．

我实现的一种算法是，当前元素比较法，通过和当前元素比较，比当前元素小，就交换，这样可以使当前元素变为当前最大值，这与冒泡排序法是不同的，
我把我的排序叫做标杆排序法，因为已经给出了比较的标准杆子！
标杆排序法，会改变相邻的相同元素的相对位置，仔细想一想不会！因为前一个交换到标杆位置之后，后一个马上会交换到相邻的标杆位置，这样两者的相对相邻位置依然没有变

我不知道考虑这个有什么好处，训练一下思维？我想知道在排序中保持相邻相同元素位置不变的价值！


这么说吧，一个班的学生已经按照学号大小排好序了，我现在要求按照年龄从小到大再排个序，如果年龄相同的，必须按照学号从小到大的顺序排列。
那么问题来了，你选择的年龄排序方法如果是不稳定的，是不是排序完了后年龄相同的一组学生学号就乱了，你就得把这组年龄相同的学生再按照学号拍一遍。如果是稳定的排序算法，我就只需要按照年龄排一遍就好了。

这样看来稳定的排序算法是不是节省了时间。稳定性的优点就体会出来了。

对这个问题，我可以作出的测试办法是
建立一个二元数组
二元数组的第一个数是学号，第二个数是年龄
年龄需要有多个重复
学号：1 2 3 4 5 6 7 8
年龄：8 8 8 7 2 4 6 6
这里如果还保持１２３，８８８就是稳定排序
如果变为３２１，８８８就是不稳定排序

我的第一步是先实现理解各种排序算法的实现原理
之后再分析各种算法的时间复杂度，空间复杂度，以及稳定性等的性质．
先做好第一步！


在计算机科学所使用的排序算法通常被分类为：

    计算的复杂度（最差、平均、和最好性能），依据列表（list）的大小（n）。一般而言，好的性能是O(n log n)，且坏的性能是O(n2)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(n log n)。
    内存使用量（以及其他电脑资源的使用）
    稳定度：稳定排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。也就是一个排序算法是稳定的，就是当有两个有相等关键的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。
    一般的方法：插入、交换、选择、合并等等。交换排序包含冒泡排序和快速排序。选择排序包含希尔排序和堆排序

平均时间复杂度由高到低为：

    冒泡排序 O(n2)
    插入排序 O(n2)
    选择排序 O(n2)
    归并排序 O(n log n)
    堆排序 O(n log n)
    快速排序 O(n log n)
    希尔排序 O(n1.25)
    基数排序 O(n)


稳定的

    冒泡排序（bubble sort） — O(n2)
    鸡尾酒排序 (Cocktail sort, 双向的冒泡排序) — O(n2)
    插入排序 （insertion sort）— O(n2)
    桶排序 （bucket sort）— O(n); 需要 O(k) 额外空间
    计数排序 (counting sort) — O(n+k); 需要 O(n+k) 额外空间
    合并排序 （merge sort）— O(n log n); 需要 O(n) 额外空间
    原地合并排序 — O(n2)
    二叉排序树排序 （Binary tree sort） — O(n log n)期望时间; O(n2)最坏时间; 需要 O(n) 额外空间
    鸽巢排序 (Pigeonhole sort) — O(n+k); 需要 O(k) 额外空间
    基数排序 （radix sort）— O(n·k); 需要 O(n) 额外空间
    Gnome 排序 — O(n2)
    图书馆排序 — O(n log n) with high probability, 需要 (1+ε)n 额外空间

不稳定

    选择排序 （selection sort）— O(n2)
    希尔排序 （shell sort）— O(n log n) 如果使用最佳的现在版本
    组合排序 — O(n log n)
    堆排序 （heapsort）— O(n log n)
    平滑排序 — O(n log n)
    快速排序 （quicksort）— O(n log n) 期望时间, O(n2) 最坏情况; 对于大的、乱数列表一般相信是最快的已知排序
    Introsort — O(n log n)
    Patience sorting — O(n log n + k) 最坏情况时间，需要 额外的 O(n + k) 空间，也需要找到最长的递增子序列
